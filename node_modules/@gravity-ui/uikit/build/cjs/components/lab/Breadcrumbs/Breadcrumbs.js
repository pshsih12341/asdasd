"use strict";
'use client';
Object.defineProperty(exports, "__esModule", { value: true });
exports.BreadcrumbsItem = exports.Breadcrumbs = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const hooks_1 = require("../../../hooks");
const Button_1 = require("../../Button");
const DropdownMenu_1 = require("../../DropdownMenu");
const filterDOMProps_1 = require("../../utils/filterDOMProps");
const BreadcrumbItem_1 = require("./BreadcrumbItem");
const BreadcrumbsSeparator_1 = require("./BreadcrumbsSeparator");
const i18n_1 = tslib_1.__importDefault(require("./i18n"));
const utils_1 = require("./utils");
require("./Breadcrumbs.css");
function Item(_props) {
    return null;
}
exports.BreadcrumbsItem = Item;
exports.Breadcrumbs = react_1.default.forwardRef(function Breadcrumbs(props, ref) {
    const listRef = react_1.default.useRef(null);
    const containerRef = (0, hooks_1.useForkRef)(ref, listRef);
    const items = [];
    react_1.default.Children.forEach(props.children, (child, index) => {
        if (react_1.default.isValidElement(child)) {
            if (child.key === undefined || child.key === null) {
                child = react_1.default.cloneElement(child, { key: index });
            }
            items.push(child);
        }
    });
    const [visibleItemsCount, setVisibleItemsCount] = react_1.default.useState(items.length);
    const [calculated, setCalculated] = react_1.default.useState(false);
    const recalculate = (visibleItems) => {
        const list = listRef.current;
        if (!list) {
            return;
        }
        const listItems = Array.from(list.children);
        if (listItems.length === 0) {
            return;
        }
        const containerWidth = list.offsetWidth;
        let newVisibleItemsCount = 0;
        let calculatedWidth = 0;
        let maxItems = props.maxItems || Infinity;
        let rootWidth = 0;
        if (props.showRoot) {
            const item = listItems.shift();
            if (item) {
                rootWidth = item.scrollWidth;
                calculatedWidth += rootWidth;
            }
            newVisibleItemsCount++;
        }
        const hasMenu = items.length > visibleItems;
        if (hasMenu) {
            const item = listItems.shift();
            if (item) {
                calculatedWidth += item.offsetWidth;
            }
            maxItems--;
        }
        if (props.showRoot && calculatedWidth >= containerWidth) {
            calculatedWidth -= rootWidth;
            newVisibleItemsCount--;
        }
        const lastItem = listItems.pop();
        if (lastItem) {
            calculatedWidth += Math.min(lastItem.offsetWidth, 200);
            if (calculatedWidth < containerWidth) {
                newVisibleItemsCount++;
            }
        }
        for (let i = listItems.length - 1; i >= 0; i--) {
            const item = listItems[i];
            calculatedWidth += item.offsetWidth;
            if (calculatedWidth >= containerWidth) {
                break;
            }
            newVisibleItemsCount++;
        }
        newVisibleItemsCount = Math.max(Math.min(maxItems, newVisibleItemsCount), 1);
        if (newVisibleItemsCount === visibleItemsCount) {
            setCalculated(true);
        }
        else {
            setVisibleItemsCount(newVisibleItemsCount);
        }
    };
    const handleResize = react_1.default.useCallback(() => {
        setCalculated(false);
        setVisibleItemsCount(items.length);
    }, [items.length]);
    (0, hooks_1.useResizeObserver)({
        ref: listRef,
        onResize: handleResize,
    });
    const lastChildren = react_1.default.useRef(null);
    react_1.default.useLayoutEffect(() => {
        if (calculated && props.children !== lastChildren.current) {
            lastChildren.current = props.children;
            setCalculated(false);
            setVisibleItemsCount(items.length);
        }
    }, [calculated, items.length, props.children]);
    react_1.default.useLayoutEffect(() => {
        if (!calculated) {
            recalculate(visibleItemsCount);
        }
    });
    const { navigate } = props;
    let contents = items;
    if (items.length > visibleItemsCount) {
        contents = [];
        const breadcrumbs = [...items];
        let endItems = visibleItemsCount;
        if (props.showRoot && visibleItemsCount > 1) {
            const rootItem = breadcrumbs.shift();
            if (rootItem) {
                contents.push(rootItem);
            }
            endItems--;
        }
        const hiddenItems = breadcrumbs.slice(0, -endItems);
        const menuItem = (react_1.default.createElement(BreadcrumbItem_1.BreadcrumbItem, { itemType: "menu" },
            react_1.default.createElement(DropdownMenu_1.DropdownMenu, { items: hiddenItems.map((el, index) => {
                    return Object.assign(Object.assign({}, el.props), { text: el.props.children, disabled: props.disabled, items: [], action: (event) => {
                            var _a;
                            if (typeof props.onAction === 'function') {
                                props.onAction((_a = el.key) !== null && _a !== void 0 ? _a : index);
                            }
                            // TODO: move this logic to DropdownMenu
                            const target = event.currentTarget;
                            if (typeof navigate === 'function' &&
                                target instanceof HTMLAnchorElement) {
                                if (el.props.href && (0, utils_1.shouldClientNavigate)(target, event)) {
                                    event.preventDefault();
                                    navigate(el.props.href, el.props.routerOptions);
                                }
                            }
                        } });
                }), popupProps: {
                    className: (0, utils_1.b)('popup', {
                        staircase: props.popupStyle === 'staircase',
                    }),
                    placement: props.popupPlacement,
                }, renderSwitcher: ({ onClick }) => (react_1.default.createElement(Button_1.Button, { title: (0, i18n_1.default)('label_more'), className: (0, utils_1.b)('more-button'), onClick: onClick, size: "s", view: "flat", disabled: props.disabled },
                    react_1.default.createElement(Button_1.Button.Icon, null, "..."))) })));
        contents.push(menuItem);
        contents.push(...breadcrumbs.slice(-endItems));
    }
    const lastIndex = contents.length - 1;
    const breadcrumbItems = contents.map((child, index) => {
        var _a;
        const isCurrent = index === lastIndex;
        const key = (_a = child.key) !== null && _a !== void 0 ? _a : index;
        const handleAction = () => {
            if (typeof props.onAction === 'function') {
                props.onAction(key);
            }
        };
        return (react_1.default.createElement("li", { key: index, className: (0, utils_1.b)('item', { calculating: !calculated }) },
            react_1.default.createElement(BreadcrumbItem_1.BreadcrumbItem, Object.assign({}, child.props, { key: key, current: isCurrent, disabled: props.disabled, onAction: handleAction, navigate: navigate }), child.props.children),
            isCurrent ? null : react_1.default.createElement(BreadcrumbsSeparator_1.BreadcrumbsSeparator, { separator: props.separator })));
    });
    return (react_1.default.createElement("ol", Object.assign({ ref: containerRef }, (0, filterDOMProps_1.filterDOMProps)(props, { labelable: true }), { "data-qa": props.qa, className: (0, utils_1.b)(null, props.className), style: props.style }), breadcrumbItems));
});
exports.Breadcrumbs.Item = Item;
exports.Breadcrumbs.displayName = 'Breadcrumbs';
