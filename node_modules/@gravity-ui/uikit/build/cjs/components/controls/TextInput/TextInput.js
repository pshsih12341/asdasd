"use strict";
'use client';
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextInput = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const icons_1 = require("@gravity-ui/icons");
const hooks_1 = require("../../../hooks");
const private_1 = require("../../../hooks/private");
const Icon_1 = require("../../Icon");
const Popover_1 = require("../../Popover");
const cn_1 = require("../../utils/cn");
const common_1 = require("../common");
const OuterAdditionalContent_1 = require("../common/OuterAdditionalContent/OuterAdditionalContent");
const utils_1 = require("../utils");
const AdditionalContent_1 = require("./AdditionalContent");
const TextInputControl_1 = require("./TextInputControl");
require("./TextInput.css");
const b = (0, cn_1.block)('text-input');
exports.TextInput = react_1.default.forwardRef(
// eslint-disable-next-line complexity
function TextInput(props, ref) {
    const { view = 'normal', size = 'm', pin = 'round-round', name, value, defaultValue, label, disabled, readOnly, hasClear = false, error, errorMessage: errorMessageProp, errorPlacement: errorPlacementProp = 'outside', validationState: validationStateProp, autoComplete, id: idProp, tabIndex, style, className, qa, controlProps: controlPropsProp, leftContent, rightContent, startContent = leftContent, endContent = rightContent, unstable_endContent: unstableEndContent, note, onUpdate, onChange, } = props;
    const { errorMessage, errorPlacement, validationState } = (0, utils_1.errorPropsMapper)({
        error,
        errorMessage: errorMessageProp,
        errorPlacement: errorPlacementProp,
        validationState: validationStateProp,
    });
    const [inputValue, setInputValue] = (0, hooks_1.useControlledState)(value, defaultValue !== null && defaultValue !== void 0 ? defaultValue : '', onUpdate);
    const innerControlRef = react_1.default.useRef(null);
    const fieldRef = (0, private_1.useFormResetHandler)({ initialValue: inputValue, onReset: setInputValue });
    const handleRef = (0, hooks_1.useForkRef)(props.controlRef, innerControlRef, fieldRef);
    const labelRef = react_1.default.useRef(null);
    const startContentRef = react_1.default.useRef(null);
    const state = (0, utils_1.getInputControlState)(validationState);
    const isLabelVisible = Boolean(label);
    const isErrorMsgVisible = validationState === 'invalid' && Boolean(errorMessage) && errorPlacement === 'outside';
    const isErrorIconVisible = validationState === 'invalid' && Boolean(errorMessage) && errorPlacement === 'inside';
    const isClearControlVisible = Boolean(hasClear && !disabled && !readOnly && inputValue);
    const isStartContentVisible = Boolean(startContent);
    const isUnstableEndContentVisible = Boolean(unstableEndContent);
    const isEndContentVisible = Boolean(endContent) && !isUnstableEndContentVisible;
    const isAutoCompleteOff = isLabelVisible && !idProp && !name && typeof autoComplete === 'undefined';
    const innerId = (0, hooks_1.useUniqId)();
    const id = isLabelVisible ? idProp || innerId : idProp;
    const labelSize = (0, private_1.useElementSize)(isLabelVisible ? labelRef : null, size);
    const startContentSize = (0, private_1.useElementSize)(isStartContentVisible ? startContentRef : null, size);
    const errorMessageId = (0, hooks_1.useUniqId)();
    const noteId = (0, hooks_1.useUniqId)();
    const ariaDescribedBy = [
        controlPropsProp === null || controlPropsProp === void 0 ? void 0 : controlPropsProp['aria-describedby'],
        note ? noteId : undefined,
        isErrorMsgVisible ? errorMessageId : undefined,
    ]
        .filter(Boolean)
        .join(' ');
    const controlProps = Object.assign(Object.assign({}, controlPropsProp), { style: Object.assign(Object.assign({}, controlPropsProp === null || controlPropsProp === void 0 ? void 0 : controlPropsProp.style), (isLabelVisible && labelSize.width
            ? { paddingInlineStart: `${labelSize.width}px` }
            : {})), 'aria-invalid': validationState === 'invalid' || undefined, 'aria-describedby': ariaDescribedBy || undefined });
    const commonProps = {
        id,
        tabIndex,
        name,
        onChange(event) {
            setInputValue(event.target.value);
            if (onChange) {
                onChange(event);
            }
        },
        autoComplete: isAutoCompleteOff ? 'off' : (0, utils_1.prepareAutoComplete)(autoComplete),
        controlProps,
    };
    const handleClear = (event) => {
        setInputValue('');
        const control = innerControlRef.current;
        if (control) {
            const syntheticEvent = Object.create(event);
            syntheticEvent.target = control;
            syntheticEvent.currentTarget = control;
            control.value = '';
            if (onChange) {
                onChange(syntheticEvent);
            }
        }
    };
    const handleAdditionalContentClick = (event) => {
        var _a, _b;
        const needActivateInput = !event.currentTarget.contains(document.activeElement) &&
            event.currentTarget.contains(event.target);
        const hasSelection = Boolean((_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.toString());
        if (needActivateInput && !hasSelection) {
            (_b = innerControlRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        }
    };
    return (react_1.default.createElement("span", { ref: ref, style: style, className: b({
            view,
            size,
            disabled,
            state,
            pin: view === 'clear' ? undefined : pin,
            'has-clear': isClearControlVisible,
            'has-start-content': isStartContentVisible,
            'has-end-content': isClearControlVisible ||
                isEndContentVisible ||
                isUnstableEndContentVisible,
            'has-unstable-end-content': isUnstableEndContentVisible,
        }, className), "data-qa": qa },
        react_1.default.createElement("span", { className: b('content') },
            isStartContentVisible && (react_1.default.createElement(AdditionalContent_1.AdditionalContent, { ref: startContentRef, placement: "start", onClick: handleAdditionalContentClick }, startContent)),
            isLabelVisible && (react_1.default.createElement("label", { ref: labelRef, style: {
                    insetInlineStart: isStartContentVisible
                        ? startContentSize.width
                        : undefined,
                    maxWidth: `calc(50% - ${startContentSize.width}px)`,
                }, className: b('label'), title: label, htmlFor: id }, `${label}`)),
            react_1.default.createElement(TextInputControl_1.TextInputControl, Object.assign({}, props, commonProps, { controlRef: handleRef })),
            isClearControlVisible && (react_1.default.createElement(common_1.ClearButton, { size: (0, common_1.mapTextInputSizeToButtonSize)(size), onClick: handleClear, className: b('clear', { size }) })),
            isEndContentVisible && (react_1.default.createElement(AdditionalContent_1.AdditionalContent, { placement: "end", onClick: handleAdditionalContentClick }, endContent)),
            isErrorIconVisible && (react_1.default.createElement(Popover_1.Popover, { content: errorMessage },
                react_1.default.createElement("span", { "data-qa": utils_1.CONTROL_ERROR_ICON_QA },
                    react_1.default.createElement(Icon_1.Icon, { data: icons_1.TriangleExclamation, className: b('error-icon'), size: size === 's' ? 12 : 16 })))),
            isUnstableEndContentVisible && (react_1.default.createElement(AdditionalContent_1.AdditionalContent, { placement: "end", onClick: handleAdditionalContentClick }, unstableEndContent))),
        react_1.default.createElement(OuterAdditionalContent_1.OuterAdditionalContent, { note: note, errorMessage: isErrorMsgVisible ? errorMessage : null, noteId: noteId, errorMessageId: errorMessageId })));
});
