"use strict";
'use client';
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableColumnSetup = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const icons_1 = require("@gravity-ui/icons");
const react_beautiful_dnd_1 = require("react-beautiful-dnd");
const hooks_1 = require("../../../../../hooks");
const useActionHandlers_1 = require("../../../../../hooks/useActionHandlers/useActionHandlers");
const Button_1 = require("../../../../Button");
const Icon_1 = require("../../../../Icon");
const Text_1 = require("../../../../Text");
const TreeSelect_1 = require("../../../../TreeSelect/TreeSelect");
const TextInput_1 = require("../../../../controls/TextInput");
const Flex_1 = require("../../../../layout/Flex/Flex");
const useList_1 = require("../../../../useList");
const cn_1 = require("../../../../utils/cn");
const i18n_1 = tslib_1.__importDefault(require("./i18n"));
require("./TableColumnSetup.css");
const b = (0, cn_1.block)('inner-table-column-setup');
const controlsCn = b('controls');
const filterInputCn = b('filter-input');
const emptyPlaceholderCn = b('empty-placeholder');
const reorderArray = (list, startIndex, endIndex) => {
    const result = [...list];
    const [removed] = result.splice(startIndex, 1);
    result.splice(endIndex, 0, removed);
    return result;
};
const prepareStickyState = (itemsById, visibleFlattenIds) => {
    let lastStickyStartIdx = 0;
    for (; lastStickyStartIdx !== visibleFlattenIds.length; lastStickyStartIdx++) {
        const visibleFlattenId = visibleFlattenIds[lastStickyStartIdx];
        const item = itemsById[visibleFlattenId];
        if ((item === null || item === void 0 ? void 0 : item.sticky) !== 'left' && (item === null || item === void 0 ? void 0 : item.sticky) !== 'start') {
            break;
        }
    }
    let firstStickyEndIdx = visibleFlattenIds.length;
    for (; firstStickyEndIdx !== 0; firstStickyEndIdx--) {
        const visibleFlattenId = visibleFlattenIds[firstStickyEndIdx - 1];
        const item = itemsById[visibleFlattenId];
        if ((item === null || item === void 0 ? void 0 : item.sticky) !== 'right' && (item === null || item === void 0 ? void 0 : item.sticky) !== 'end') {
            break;
        }
    }
    return {
        stickyStartItemIdList: visibleFlattenIds.slice(0, lastStickyStartIdx),
        sortableItemIdList: visibleFlattenIds.slice(lastStickyStartIdx, firstStickyEndIdx),
        stickyEndItemIdList: visibleFlattenIds.slice(firstStickyEndIdx),
    };
};
const prepareValue = (tableColumnItems) => {
    const selectedIds = [];
    tableColumnItems.forEach(({ id, isSelected }) => {
        if (isSelected) {
            selectedIds.push(id);
        }
    });
    return selectedIds;
};
const RENDER_DRAG_DISABLED_CONTAINER_PROPS = { isDragDisabled: true };
const useDndRenderContainer = ({ onDragEnd, renderControls }) => {
    const uniqId = (0, hooks_1.useUniqId)();
    const dndRenderContainer = ({ renderItem, list, containerRef, id, className, }) => {
        const renderDndActiveItem = (provided, snapshot, rubric) => {
            const renderContainerProps = {
                provided,
                snapshot,
            };
            return renderItem(list.structure.visibleFlattenIds[rubric.source.index], rubric.source.index, renderContainerProps);
        };
        const { stickyStartItemIdList, sortableItemIdList, stickyEndItemIdList } = prepareStickyState(list.structure.itemsById, list.structure.visibleFlattenIds);
        const stickyStartItemList = stickyStartItemIdList.map((visibleFlattenId, idx) => {
            return renderItem(visibleFlattenId, idx, RENDER_DRAG_DISABLED_CONTAINER_PROPS);
        });
        const sortableItemList = sortableItemIdList.map((visibleFlattenId, idx) => {
            return renderItem(visibleFlattenId, idx + stickyStartItemIdList.length);
        });
        const stickyEndItemList = stickyEndItemIdList.map((visibleFlattenId, idx) => {
            return renderItem(visibleFlattenId, stickyStartItemList.length + sortableItemList.length + idx, RENDER_DRAG_DISABLED_CONTAINER_PROPS);
        });
        return (react_1.default.createElement(react_1.default.Fragment, null,
            react_1.default.createElement(useList_1.ListContainerView, { ref: containerRef, id: id, className: className },
                stickyStartItemList,
                react_1.default.createElement(react_beautiful_dnd_1.DragDropContext, { onDragEnd: onDragEnd },
                    react_1.default.createElement(react_beautiful_dnd_1.Droppable, { droppableId: uniqId, renderClone: renderDndActiveItem }, (droppableProvided) => {
                        return (react_1.default.createElement("div", Object.assign({}, droppableProvided.droppableProps, { ref: droppableProvided.innerRef }),
                            sortableItemList,
                            droppableProvided.placeholder));
                    })),
                stickyEndItemList),
            react_1.default.createElement("div", { className: controlsCn }, renderControls())));
    };
    return dndRenderContainer;
};
const useDndRenderItem = (sortable) => {
    const renderDndItem = ({ data: item, props, index, renderContainerProps, }) => {
        const isDragDisabled = sortable === false || (renderContainerProps === null || renderContainerProps === void 0 ? void 0 : renderContainerProps.isDragDisabled) === true;
        const endSlot = isDragDisabled ? undefined : react_1.default.createElement(Icon_1.Icon, { data: icons_1.Grip, size: 16 });
        const startSlot = item.isRequired ? react_1.default.createElement(Icon_1.Icon, { data: icons_1.Lock }) : undefined;
        const selected = item.isRequired ? false : props.selected;
        const commonProps = Object.assign(Object.assign({}, props), { selected, selectionViewType: item.isRequired ? 'single' : 'multiple', content: Object.assign(Object.assign({}, props.content), { startSlot,
                endSlot }) });
        if (isDragDisabled) {
            return react_1.default.createElement(useList_1.ListItemView, Object.assign({}, commonProps, { key: commonProps.id }));
        }
        const renderItem = (provided, snapshot) => (react_1.default.createElement(useList_1.ListItemView, Object.assign({}, commonProps, provided.draggableProps, provided.dragHandleProps, { ref: provided.innerRef, dragging: snapshot.isDragging })));
        if ((renderContainerProps === null || renderContainerProps === void 0 ? void 0 : renderContainerProps.provided) && renderContainerProps.snapshot) {
            return renderItem(renderContainerProps.provided, renderContainerProps.snapshot);
        }
        return (react_1.default.createElement(react_beautiful_dnd_1.Draggable, { draggableId: props.id, index: index, key: `item-key-${props.id}`, isDragDisabled: isDragDisabled }, renderItem));
    };
    return renderDndItem;
};
const mapItemDataToContentProps = (item) => {
    return {
        title: item.title,
    };
};
const defaultFilterSettingsFn = (value, item) => {
    return typeof item.title === 'string'
        ? item.title.toLowerCase().includes(value.trim().toLowerCase())
        : true;
};
const useEmptyRenderContainer = (placeholder) => {
    const emptyRenderContainer = () => react_1.default.createElement(Text_1.Text, { className: emptyPlaceholderCn }, placeholder);
    return emptyRenderContainer;
};
const TableColumnSetup = (props) => {
    const { renderSwitcher, popupWidth, popupPlacement, items: propsItems, onUpdate: propsOnUpdate, sortable, renderControls, className, defaultItems = propsItems, showResetButton: propsShowResetButton, filterable, filterPlaceholder, filterEmptyMessage, filterSettings = defaultFilterSettingsFn, } = props;
    const [open, setOpen] = react_1.default.useState(false);
    const [sortingEnabled, setSortingEnabled] = react_1.default.useState(sortable);
    const [prevSortingEnabled, setPrevSortingEnabled] = react_1.default.useState(sortable);
    if (sortable !== prevSortingEnabled) {
        setPrevSortingEnabled(sortable);
        setSortingEnabled(sortable);
    }
    const [items, setItems] = react_1.default.useState(propsItems);
    const [prevPropsItems, setPrevPropsItems] = react_1.default.useState(propsItems);
    if (propsItems !== prevPropsItems) {
        setPrevPropsItems(propsItems);
        setItems(propsItems);
    }
    const filterState = (0, useList_1.useListFilter)({ items, filterItem: filterSettings, debounceTimeout: 0 });
    const onApply = () => {
        const newSettings = items.map(({ id, isSelected }) => ({ id, isSelected }));
        propsOnUpdate(newSettings);
        onOpenChange(false);
    };
    const DefaultApplyButton = () => (react_1.default.createElement(Button_1.Button, { view: "action", width: "max", onClick: onApply }, (0, i18n_1.default)('button_apply')));
    const onDragEnd = ({ destination, source }) => {
        if ((destination === null || destination === void 0 ? void 0 : destination.index) !== undefined && (destination === null || destination === void 0 ? void 0 : destination.index) !== source.index) {
            setItems((prevItems) => {
                return reorderArray(prevItems, source.index, destination.index);
            });
        }
    };
    const showResetButton = typeof propsShowResetButton === 'function'
        ? propsShowResetButton(items)
        : propsShowResetButton;
    const dndRenderContainer = useDndRenderContainer({
        onDragEnd,
        renderControls: () => renderControls ? (renderControls({ DefaultApplyButton, onApply })) : (react_1.default.createElement(Flex_1.Flex, { gapRow: 1, direction: "column", className: controlsCn },
            showResetButton && (react_1.default.createElement(Button_1.Button, { onClick: () => {
                    setItems(defaultItems);
                }, width: "max" }, (0, i18n_1.default)('button_reset'))),
            react_1.default.createElement(DefaultApplyButton, null))),
    });
    const dndRenderItem = useDndRenderItem(sortingEnabled);
    const renderControl = ({ toggleOpen }) => {
        const onKeyDown = (0, useActionHandlers_1.createOnKeyDownHandler)(toggleOpen);
        return ((renderSwitcher === null || renderSwitcher === void 0 ? void 0 : renderSwitcher({ onClick: toggleOpen, onKeyDown })) || (react_1.default.createElement(Button_1.Button, { onClick: toggleOpen, extraProps: { onKeyDown } },
            react_1.default.createElement(Icon_1.Icon, { data: icons_1.Gear }),
            (0, i18n_1.default)('button_switcher'))));
    };
    const onOpenChange = (open) => {
        setOpen(open);
        if (open === false) {
            setItems(propsItems);
            setSortingEnabled(sortable);
            filterState.reset();
        }
    };
    const onUpdate = (selectedItemsIds) => {
        setItems((prevItems) => {
            return prevItems.map((item) => (Object.assign(Object.assign({}, item), { isSelected: item.isRequired || selectedItemsIds.includes(item.id) })));
        });
    };
    const value = react_1.default.useMemo(() => prepareValue(items), [items]);
    const emptyRenderContainer = useEmptyRenderContainer(filterEmptyMessage);
    const onFilterValueUpdate = (value) => {
        filterState.onFilterUpdate(value);
        setSortingEnabled(!value.length);
    };
    const slotBeforeListBody = filterable ? (react_1.default.createElement(TextInput_1.TextInput, { size: "m", view: "clear", placeholder: filterPlaceholder, value: filterState.filter, className: filterInputCn, onUpdate: onFilterValueUpdate, hasClear: true })) : null;
    const renderContainer = filterState.filter && !filterState.items.length ? emptyRenderContainer : dndRenderContainer;
    return (react_1.default.createElement(TreeSelect_1.TreeSelect, { className: b(null, className), mapItemDataToContentProps: mapItemDataToContentProps, multiple: true, size: "l", open: open, value: value, items: filterState.filter ? filterState.items : items, onUpdate: onUpdate, popupWidth: popupWidth, onOpenChange: onOpenChange, placement: popupPlacement, slotBeforeListBody: slotBeforeListBody, renderContainer: renderContainer, renderControl: renderControl, renderItem: dndRenderItem }));
};
exports.TableColumnSetup = TableColumnSetup;
