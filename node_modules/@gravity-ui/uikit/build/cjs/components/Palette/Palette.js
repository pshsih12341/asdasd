"use strict";
'use client';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Palette = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const hooks_1 = require("../../hooks");
const useForkRef_1 = require("../../hooks/useForkRef/useForkRef");
const Button_1 = require("../Button");
const cn_1 = require("../utils/cn");
const filterDOMProps_1 = require("../utils/filterDOMProps");
const hooks_2 = require("./hooks");
const utils_1 = require("./utils");
require("./Palette.css");
const b = (0, cn_1.block)('palette');
exports.Palette = react_1.default.forwardRef(function Palette(props, ref) {
    const { size = 'm', multiple = true, options = [], columns = 6, disabled, style, className, rowClassName, optionClassName, qa, onFocus, onBlur, } = props;
    const [focusedOptionIndex, setFocusedOptionIndex] = react_1.default.useState(undefined);
    const focusedOption = focusedOptionIndex === undefined ? undefined : options[focusedOptionIndex];
    const innerRef = react_1.default.useRef(null);
    const handleRef = (0, useForkRef_1.useForkRef)(ref, innerRef);
    const { value, handleSelection } = (0, hooks_1.useSelect)({
        value: props.value,
        defaultValue: props.defaultValue,
        multiple,
        onUpdate: props.onUpdate,
    });
    const rows = react_1.default.useMemo(() => (0, utils_1.getPaletteRows)(options, columns), [columns, options]);
    const focusOnOptionWithIndex = react_1.default.useCallback((index) => {
        if (!innerRef.current)
            return;
        const $options = Array.from(innerRef.current.querySelectorAll(`.${b('option')}`));
        if (!$options[index])
            return;
        $options[index].focus();
        setFocusedOptionIndex(index);
    }, []);
    const tryToFocus = (newIndex) => {
        if (newIndex === focusedOptionIndex || newIndex < 0 || newIndex >= options.length) {
            return;
        }
        focusOnOptionWithIndex(newIndex);
    };
    const gridProps = (0, hooks_2.usePaletteGrid)({
        disabled,
        onFocus: (event) => {
            focusOnOptionWithIndex(0);
            onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
        },
        onBlur: (event) => {
            setFocusedOptionIndex(undefined);
            onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
        },
        whenFocused: focusedOptionIndex !== undefined && focusedOption
            ? {
                selectItem: () => handleSelection(focusedOption),
                nextItem: () => tryToFocus(focusedOptionIndex + 1),
                previousItem: () => tryToFocus(focusedOptionIndex - 1),
                nextRow: () => tryToFocus(focusedOptionIndex + columns),
                previousRow: () => tryToFocus(focusedOptionIndex - columns),
            }
            : undefined,
    });
    return (react_1.default.createElement("div", Object.assign({}, (0, filterDOMProps_1.filterDOMProps)(props, { labelable: true }), gridProps, { ref: handleRef, className: b({ size }, className), style: style, "data-qa": qa }), rows.map((row, rowNumber) => (react_1.default.createElement("div", { className: b('row', rowClassName), key: `row-${rowNumber}`, role: "row" }, row.map((option) => {
        var _a;
        const isSelected = Boolean(value.includes(option.value));
        const focused = option === focusedOption;
        return (react_1.default.createElement("div", { key: option.value, role: "gridcell", "aria-selected": focused ? 'true' : undefined, "aria-readonly": option.disabled },
            react_1.default.createElement(Button_1.Button, { className: b('option', optionClassName), tabIndex: -1, style: style, disabled: disabled || option.disabled, title: option.title, view: isSelected ? 'normal' : 'flat', selected: isSelected, extraProps: { value: option.value }, size: size, onClick: () => handleSelection(option) },
                react_1.default.createElement(Button_1.Button.Icon, null, (_a = option.content) !== null && _a !== void 0 ? _a : option.value))));
    }))))));
});
exports.Palette.displayName = 'Palette';
