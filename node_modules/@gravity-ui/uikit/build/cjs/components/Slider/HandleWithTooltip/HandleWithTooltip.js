"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandleWithTooltip = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const SliderTooltip_1 = require("../SliderTooltip/SliderTooltip");
const HandleWithTooltip = ({ originHandle, originHandleProps, stateModifiers, tooltipFormat, className, }) => {
    var _a;
    const autoVisible = stateModifiers['tooltip-display'] === 'auto';
    const alwaysVisible = stateModifiers['tooltip-display'] === 'on';
    const [tooltipVisible, setTooltipVisible] = react_1.default.useState(false);
    const [focused, setFocused] = react_1.default.useState(false);
    const [hovered, setHovered] = react_1.default.useState(false);
    if (alwaysVisible && !tooltipVisible) {
        setTooltipVisible(true);
    }
    //to show tooltip on mobile devices on touch
    if (autoVisible && !tooltipVisible && originHandleProps.dragging) {
        setTooltipVisible(true);
    }
    const styleProp = stateModifiers.rtl ? 'right' : 'left';
    const tooltipContent = tooltipFormat
        ? tooltipFormat(originHandleProps.value)
        : originHandleProps.value;
    const handleTooltipVisibility = ({ currentHovered, currentFocused, }) => {
        if (autoVisible) {
            const handleHovered = currentHovered === undefined ? hovered : currentHovered;
            const handleFocused = currentFocused === undefined ? focused : currentFocused;
            setTooltipVisible(handleHovered || handleFocused);
        }
    };
    const handle = alwaysVisible
        ? originHandle
        : react_1.default.cloneElement(originHandle, {
            onMouseEnter: (event) => {
                var _a, _b;
                (_b = (_a = originHandle.props).onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, event);
                setHovered(true);
                handleTooltipVisibility({ currentHovered: true });
            },
            onMouseLeave: (event) => {
                var _a, _b;
                (_b = (_a = originHandle.props).onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, event);
                setHovered(false);
                handleTooltipVisibility({ currentHovered: false });
            },
            onFocus: (event) => {
                var _a, _b;
                (_b = (_a = originHandle.props).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);
                setFocused(true);
                handleTooltipVisibility({ currentFocused: true });
            },
            onBlur: (event) => {
                var _a, _b;
                (_b = (_a = originHandle.props).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, event);
                setFocused(false);
                handleTooltipVisibility({ currentFocused: false });
            },
        });
    return (react_1.default.createElement(react_1.default.Fragment, null,
        handle,
        tooltipVisible && (react_1.default.createElement(SliderTooltip_1.SliderTooltip, { className: className, style: {
                insetInlineStart: (_a = originHandle.props.style) === null || _a === void 0 ? void 0 : _a[styleProp],
            }, stateModifiers: stateModifiers }, tooltipContent))));
};
exports.HandleWithTooltip = HandleWithTooltip;
