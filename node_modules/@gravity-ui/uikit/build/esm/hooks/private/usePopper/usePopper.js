import React from 'react';
import { usePopper as useReactPopper } from 'react-popper';
import { useDirection } from '../../../components/theme';
const DEFAULT_PLACEMENT = [
    'bottom-start',
    'bottom',
    'bottom-end',
    'top-start',
    'top',
    'top-end',
    'right-start',
    'right',
    'right-end',
    'left-start',
    'left',
    'left-end',
];
const rtlOffsetFix = {
    name: 'rtlOffsetFix',
    enabled: true,
    phase: 'main',
    requires: ['offset'],
    fn({ state }) {
        var _a;
        if (!state.placement.startsWith('top') && !state.placement.startsWith('bottom')) {
            return;
        }
        const offsets = (_a = state.modifiersData.offset) === null || _a === void 0 ? void 0 : _a[state.placement];
        if (!offsets) {
            return;
        }
        state.modifiersData.popperOffsets.x -= offsets.x * 2;
    },
};
export function usePopper({ anchorRef, placement = DEFAULT_PLACEMENT, offset, modifiers = [], strategy, altBoundary, }) {
    const [popperElement, setPopperElement] = React.useState(null);
    const [arrowElement, setArrowElement] = React.useState(null);
    const direction = useDirection();
    const placements = React.useMemo(() => {
        let items = Array.isArray(placement) ? placement : [placement];
        if (direction === 'rtl') {
            items = items.map((p) => p.replace(/(top|bottom)-(start|end)/g, (match, position, value) => {
                if (value === 'start') {
                    return position + '-end';
                }
                if (value === 'end') {
                    return position + '-start';
                }
                return match;
            }));
        }
        return items;
    }, [placement, direction]);
    const { attributes, styles } = useReactPopper(anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.current, popperElement, {
        strategy,
        modifiers: [
            { name: 'arrow', options: { element: arrowElement } },
            { name: 'offset', options: { offset, altBoundary } },
            { name: 'flip', options: { fallbackPlacements: placements.slice(1), altBoundary } },
            ...(direction === 'rtl' ? [rtlOffsetFix] : []),
            ...modifiers,
        ],
        placement: placements[0],
    });
    return {
        attributes,
        styles,
        setPopperRef: setPopperElement,
        setArrowRef: setArrowElement,
    };
}
