'use client';
import React from 'react';
import _throttle from 'lodash/throttle';
import { block } from '../utils/cn';
import { BreadcrumbsItem as Item } from './BreadcrumbsItem';
import { BreadcrumbsMore } from './BreadcrumbsMore';
import { BreadcrumbsSeparator } from './BreadcrumbsSeparator';
import './Breadcrumbs.css';
const RESIZE_THROTTLE = 200;
const MORE_ITEM_WIDTH = 34;
const DEFAULT_POPUP_PLACEMENT = ['bottom', 'top'];
const GAP_WIDTH = 4;
const b = block('breadcrumbs');
export var LastDisplayedItemsCount;
(function (LastDisplayedItemsCount) {
    LastDisplayedItemsCount[LastDisplayedItemsCount["One"] = 1] = "One";
    LastDisplayedItemsCount[LastDisplayedItemsCount["Two"] = 2] = "Two";
})(LastDisplayedItemsCount || (LastDisplayedItemsCount = {}));
export var FirstDisplayedItemsCount;
(function (FirstDisplayedItemsCount) {
    FirstDisplayedItemsCount[FirstDisplayedItemsCount["Zero"] = 0] = "Zero";
    FirstDisplayedItemsCount[FirstDisplayedItemsCount["One"] = 1] = "One";
})(FirstDisplayedItemsCount || (FirstDisplayedItemsCount = {}));
export class Breadcrumbs extends React.Component {
    static prepareInitialState(props) {
        const { firstDisplayedItemsCount } = props;
        return {
            calculated: false,
            rootItem: firstDisplayedItemsCount ? props.items[0] : undefined,
            visibleItems: props.items.slice(firstDisplayedItemsCount),
            hiddenItems: [],
            allItems: props.items,
        };
    }
    static getDerivedStateFromProps(props, state) {
        if (state.allItems !== props.items) {
            return Breadcrumbs.prepareInitialState(props);
        }
        return null;
    }
    constructor(props) {
        super(props);
        this.handleResize = () => {
            const state = Breadcrumbs.prepareInitialState(this.props);
            this.setState(state, this.recalculate);
        };
        this.handleResize = _throttle(this.handleResize, RESIZE_THROTTLE);
        if (typeof window !== 'undefined') {
            this.resizeObserver = new ResizeObserver(this.handleResize);
        }
        this.container = React.createRef();
        this.state = Breadcrumbs.prepareInitialState(props);
    }
    componentDidMount() {
        var _a;
        this.recalculate();
        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.observe(this.container.current);
    }
    componentDidUpdate(prevProps) {
        if (prevProps.items !== this.state.allItems) {
            this.recalculate();
        }
    }
    componentWillUnmount() {
        var _a;
        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    render() {
        const { className, qa } = this.props;
        const { calculated } = this.state;
        return (React.createElement("div", { className: b({ calculated: calculated ? 'yes' : 'no' }, className), "data-qa": qa },
            React.createElement("div", { className: b('inner'), ref: this.container },
                this.renderRootItem(),
                this.renderMoreItem(),
                this.renderVisibleItems())));
    }
    renderItem(item, isCurrent, isPrevCurrent, renderItemContent) {
        return (React.createElement(Item, { item: item, isCurrent: isCurrent, isPrevCurrent: isPrevCurrent, renderItemContent: renderItemContent || this.props.renderItemContent, renderItem: this.props.renderItem }));
    }
    renderItemDivider() {
        const { renderItemDivider } = this.props;
        return React.createElement(BreadcrumbsSeparator, { renderItemDivider: renderItemDivider });
    }
    renderRootItem() {
        const { renderRootContent } = this.props;
        const { rootItem, visibleItems } = this.state;
        const isCurrent = visibleItems.length === 0;
        if (!rootItem) {
            return null;
        }
        return this.renderItem(rootItem, isCurrent, false, renderRootContent);
    }
    renderVisibleItems() {
        const { visibleItems } = this.state;
        return visibleItems.map((item, index, items) => {
            const isCurrent = index === items.length - 1;
            const isPrevCurrent = index === items.length - 2;
            return (React.createElement(React.Fragment, { key: index },
                this.renderItemDivider(),
                this.renderItem(item, isCurrent, isPrevCurrent)));
        });
    }
    renderMoreItem() {
        const { hiddenItems } = this.state;
        if (hiddenItems.length === 0) {
            return null;
        }
        const { popupStyle, popupPlacement, renderItemDivider } = this.props;
        return (React.createElement(React.Fragment, null,
            React.createElement(BreadcrumbsSeparator, { renderItemDivider: renderItemDivider }),
            React.createElement(BreadcrumbsMore, { items: hiddenItems, popupPlacement: popupPlacement, popupStyle: popupStyle })));
    }
    recalculate() {
        var _a;
        const { items: allItems, lastDisplayedItemsCount, firstDisplayedItemsCount } = this.props;
        let availableWidth = ((_a = this.container.current) === null || _a === void 0 ? void 0 : _a.offsetWidth) || 0;
        if (this.container.current && availableWidth > 0) {
            availableWidth += GAP_WIDTH;
            const dividers = Array.from(this.container.current.querySelectorAll(`.${b('divider')}`));
            const items = [
                ...Array.from(this.container.current.querySelectorAll(`.${b('switcher')}`)),
                ...Array.from(this.container.current.querySelectorAll(`.${b('item')}`)),
            ];
            const itemsWidths = items.map((elem, i) => elem.scrollWidth + (i === items.length - 1 ? GAP_WIDTH : GAP_WIDTH * 2));
            const dividersWidths = dividers.map((elem) => elem.offsetWidth);
            const buttonsWidth = itemsWidths.reduce((total, width, index, widths) => {
                const isLastItem = widths.length - 1 === index;
                const isItemBeforeLast = lastDisplayedItemsCount === LastDisplayedItemsCount.Two &&
                    widths.length - 2 === index;
                if (isLastItem || isItemBeforeLast) {
                    return total + Math.min(width, 200);
                }
                return total + width;
            }, 0);
            const dividersWidth = dividersWidths.reduce((total, width) => total + width, 0);
            let totalWidth = buttonsWidth + dividersWidth;
            let visibleItemsStartIndex = 1;
            while (totalWidth > availableWidth &&
                visibleItemsStartIndex < items.length - lastDisplayedItemsCount) {
                if (visibleItemsStartIndex === 1) {
                    totalWidth += MORE_ITEM_WIDTH + dividersWidths[visibleItemsStartIndex];
                }
                totalWidth -=
                    itemsWidths[visibleItemsStartIndex] + dividersWidths[visibleItemsStartIndex];
                visibleItemsStartIndex++;
            }
            this.setState({
                calculated: true,
                visibleItems: allItems.slice(visibleItemsStartIndex - (1 - firstDisplayedItemsCount)),
                hiddenItems: allItems.slice(firstDisplayedItemsCount, visibleItemsStartIndex - (1 - firstDisplayedItemsCount)),
            });
        }
    }
}
Breadcrumbs.defaultProps = {
    popupPlacement: DEFAULT_POPUP_PLACEMENT,
};
