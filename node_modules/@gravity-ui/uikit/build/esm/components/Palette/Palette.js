'use client';
import React from 'react';
import { useSelect } from '../../hooks';
import { useForkRef } from '../../hooks/useForkRef/useForkRef';
import { Button } from '../Button';
import { block } from '../utils/cn';
import { filterDOMProps } from '../utils/filterDOMProps';
import { usePaletteGrid } from './hooks';
import { getPaletteRows } from './utils';
import './Palette.css';
const b = block('palette');
export const Palette = React.forwardRef(function Palette(props, ref) {
    const { size = 'm', multiple = true, options = [], columns = 6, disabled, style, className, rowClassName, optionClassName, qa, onFocus, onBlur, } = props;
    const [focusedOptionIndex, setFocusedOptionIndex] = React.useState(undefined);
    const focusedOption = focusedOptionIndex === undefined ? undefined : options[focusedOptionIndex];
    const innerRef = React.useRef(null);
    const handleRef = useForkRef(ref, innerRef);
    const { value, handleSelection } = useSelect({
        value: props.value,
        defaultValue: props.defaultValue,
        multiple,
        onUpdate: props.onUpdate,
    });
    const rows = React.useMemo(() => getPaletteRows(options, columns), [columns, options]);
    const focusOnOptionWithIndex = React.useCallback((index) => {
        if (!innerRef.current)
            return;
        const $options = Array.from(innerRef.current.querySelectorAll(`.${b('option')}`));
        if (!$options[index])
            return;
        $options[index].focus();
        setFocusedOptionIndex(index);
    }, []);
    const tryToFocus = (newIndex) => {
        if (newIndex === focusedOptionIndex || newIndex < 0 || newIndex >= options.length) {
            return;
        }
        focusOnOptionWithIndex(newIndex);
    };
    const gridProps = usePaletteGrid({
        disabled,
        onFocus: (event) => {
            focusOnOptionWithIndex(0);
            onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
        },
        onBlur: (event) => {
            setFocusedOptionIndex(undefined);
            onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
        },
        whenFocused: focusedOptionIndex !== undefined && focusedOption
            ? {
                selectItem: () => handleSelection(focusedOption),
                nextItem: () => tryToFocus(focusedOptionIndex + 1),
                previousItem: () => tryToFocus(focusedOptionIndex - 1),
                nextRow: () => tryToFocus(focusedOptionIndex + columns),
                previousRow: () => tryToFocus(focusedOptionIndex - columns),
            }
            : undefined,
    });
    return (React.createElement("div", Object.assign({}, filterDOMProps(props, { labelable: true }), gridProps, { ref: handleRef, className: b({ size }, className), style: style, "data-qa": qa }), rows.map((row, rowNumber) => (React.createElement("div", { className: b('row', rowClassName), key: `row-${rowNumber}`, role: "row" }, row.map((option) => {
        var _a;
        const isSelected = Boolean(value.includes(option.value));
        const focused = option === focusedOption;
        return (React.createElement("div", { key: option.value, role: "gridcell", "aria-selected": focused ? 'true' : undefined, "aria-readonly": option.disabled },
            React.createElement(Button, { className: b('option', optionClassName), tabIndex: -1, style: style, disabled: disabled || option.disabled, title: option.title, view: isSelected ? 'normal' : 'flat', selected: isSelected, extraProps: { value: option.value }, size: size, onClick: () => handleSelection(option) },
                React.createElement(Button.Icon, null, (_a = option.content) !== null && _a !== void 0 ? _a : option.value))));
    }))))));
});
Palette.displayName = 'Palette';
